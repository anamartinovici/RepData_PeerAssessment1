#list(set = set, get = get,
#    setinv = setinv,
#   getinv = getinv)
}
makeCacheMatrix()
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
print (i)
#get <- function() x
#setinv <- function(solve) i <<- solve
#getinv <- function() i
#list(set = set, get = get,
#    setinv = setinv,
#   getinv = getinv)
}
makeCacheMatrix()
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
print (i)
#get <- function() x
#setinv <- function(solve) i <<- solve
#getinv <- function() i
#list(set = set, get = get,
#    setinv = setinv,
#   getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
print (y)
#get <- function() x
#setinv <- function(solve) i <<- solve
#getinv <- function() i
#list(set = set, get = get,
#    setinv = setinv,
#   getinv = getinv)
}
makeCacheMatrix()
y<-NULL
y
makeCacheMatrix()
?<<-
?<-
?(<-)
mat<-makeCacheMatrix()
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function()
setinv <- function(solve) i <<- solve
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat<-makeCacheMatrix()
matrix()
mat
mat<-matrix(1:9,3,3)
mat
mat2<-makeCacheMatrix(mat)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(solve) i <<- solve
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat2<-makeCacheMatrix(mat)
class(mat2)
mat2
cacheSolve(mat2)
mat<-matrix(rnorm(9),3,3)
mat2<-makeCacheMatrix(mat)
cacheSolve(mat2)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setmean(i)
i
}
mat
mat2
i
i<-NULL
cacheSolve(mat2)
class(mat2$getinv)
class(mat2$get)
class(solve)
cacheSolve <- function(x) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data)
x$setmean(i)
i
}
cacheSolve(mat2)
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
#if(!is.null(i)) {
#  message("getting cached data")
#  return(i)
#}
#data <- x$get()
#i <- solve(data, ...)
#x$setmean(i)
#i
}
cacheSolve(mat2)
i
cacheSolve(mat2)
mat2$get
mat
mat2
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() xirtam
setinv <- function(inverted) i <<- inverted
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat
class(mat)
mat2<-makeCacheMatrix(mat)
class(mat2)
mat2$<-matrix(c(1,1,2,2), 2,2)
mat2$set(matrix(c(1,1,2,2), 2,2))
x
makeCacheMatrix <- function(inmat = matrix()) {
inv <- NULL
set <- function(setmat) {
inmat <<- setmat
inv <<- NULL
}
get <- function() xirtam
setinv <- function(inverted) i <<- inverted
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat
mat2<-makeCacheMatrix(mat)
mat2
mat2.get
mat2.get()
mat2$get()
makeCacheMatrix <- function(inmat = matrix()) {
inv <- NULL
set <- function(setmat) {
inmat <<- setmat
inv <<- NULL
}
get <- function() inmat
setinv <- function(inverted) i <<- inverted
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat2<-makeCacheMatrix(mat)
mat2$get()
mat2$set(matrix(c(1,1,2,2), 2,2)
)
mat2$get()
mat2$getinv()
mat2$setinv(matrix(c(2,1,2,1),2,2))
mat2$getinv()
mat2$setinv(2
)
mat2$setinv()
mat2$setinv(2)
mat2$getinv()
makeCacheMatrix <- function(inmat = matrix()) {
inv <- NULL
set <- function(setmat) {
inmat <<- setmat
inv <<- NULL
}
get <- function() inmat
setinv <- function(inverted) inv <<- inverted
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat2.setinv(1)
mat2$setinv(1)
mat2$getinv()
makeCacheMatrix <- function(inmat = matrix()) {
inv <- NULL
set <- function(setmat) {
inmat <<- setmat
inv <<- NULL
}
get <- function() inmat
setinv <- function(inverted) {inv <<- inverted}
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
mat2$getinv()
mat2$setinv(matrix(c(2,1,2,1),2,2))
mat2$getinv()
inv
inmat
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data)
x$setmean(i)
i
}
cacheSolve(mat2)
mat<-matrix(random(1:9), 3,3 )
mat<-matrix(rnorm(1:9), 3,3 )
mat
mat2<-makeCacheMatrix(mat)
cacheSolve(mat2)
## Write a short comment describing this function
cacheSolve <- function(matinv, ...) {
## Return a matrix that is the inverse of 'x'
i <- matinv$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- matinv$get()
inv <- solve(data)
x$setinv(inv)
inv
}
cacheSolve(mat2)
## Write a short comment describing this function
cacheSolve <- function(matinv, ...) {
## Return a matrix that is the inverse of 'x'
inv <- matinv$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- matinv$get()
inv <- solve(data)
x$setinv(inv)
inv
}
cacheSolve(mat2)
cacheSolve <- function(matinv, ...) {
## Return a matrix that is the inverse of 'x'
inv <- matinv$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- matinv$get()
inv <- solve(data)
matinv$setinv(inv)
inv
}
cacheSolve(mat2)
setwd("~/Google Drive/Coursera/DataScienceSpecialization/Reproducible Research /Week2")
steps<-read.csv("activity.csv")
ls
setwd("~/Google Drive/Coursera/DataScienceSpecialization/Reproducible Research /Week2/RepData_PeerAssessment1")
steps<-read.csv("activity.csv")
steps
head(steps)
mean<-mean(steps$steps)
mean
mean<-mean(steps$steps, na.rm=TRUE)
mean
?hist
hist(steps)
hist(steps$steps)
hist?
?hist
hist(steps$steps, xlab="Day")
hist(steps$steps, xlab="Day", main="Steps per day")
hist(steps$steps, xlab="Day", main="Steps per day", ylab="Steps")
?split
split(steps, steps$date)
byDate<-split(steps, steps$date)
class(byDate)
?lapply
byDate<-split(steps, steps$date)
stepsPerDay<-lapply(names(byDate), function(x) sum(byDate[x]$steps))
class(stepsPerDat)
class(stepsPerDay)
stepsPerDay
byDate[x]$steps
x<-1
byDate[x]$steps
stepsPerDay<-lapply(names(byDate), function(x) sum(byDate[x]$steps, na.rm=TRUE))
stepsPerDay
x<-1
stepsPerDay<-lapply(names(byDate), function(x) sum(byDate[x]$steps))
byDate[x]$steps
x<-3
byDate[x]$steps
stepsPerDay<-lapply(names(byDate), function(x) sum(na.rm=TRUE))
stepsPerDay
stepsPerDay<-lapply(names(byDate), sum(na.rm=TRUE))
stepsPerDay<-lapply(names(byDate), sum)
stepsPerDay<-lapply(byDate, sum)
byDate<-split(steps$steps, steps$date)
stepsPerDay<-lapply(byDate, sum)
stepsPerDay
hist(stepsPerDay, xlab="Day",               #draw histogram
main="Steps per day", ylab="Steps")
byDate<-split(steps$steps, steps$date)      #split by date
stepsPerDay<-sapply(byDate, sum)            #add steps in intervals
class(stepsPerDay)
hist(stepsPerDay, xlab="Day",               #draw histogram
main="Steps per day", ylab="Steps")
stepsPerDay
hist(stepsPerDay, xlab="Steps",               #draw histogram
main="Steps per day", ylab="Frequency")
mean<-mean(stepsPerDay, na.rm=TRUE)         #Calculate the mean steps
print(mean)
median<-median(stepsPerDay, na.rm=TRUE)     #Calculate the median steps
print(median)
?plot
steps
head(steaps)
head(steps)
byDate
head(byDate)
?split
steps
steps<-read.csv("activity.csv")             #load the data
steps
mean(steps$steps)
byInterval<-split(steps$steps, steps$interval)      #split steps by interval
stepsPerDay<-sapply(byInterval, mean)               #average steps in intervals
byInterval<-split(steps$steps, steps$interval)      #split steps by interval
stepsPerInterval<-sapply(byInterval, mean)               #average steps in intervals
stepsPerInterval
byInterval<-split(steps$steps, steps$interval, drop=TRUE)      #split steps by interval
stepsPerInterval<-sapply(byInterval, mean)               #average steps in intervals
stepsPerInterval
byInterval
?mean
stepsPerInterval<-sapply(byInterval, mean, na.rm=TRUE)               #average steps in intervals
stepsPerInterval
plot(stepsPerInterval, type='l')
plot(stepsPerInterval, type='l', xlab="5-minute Interval", ylab=steps, main="Steps per 5-minute interval across days")
plot(stepsPerInterval, type='l', xlab="5-minute Interval", ylab="steps",
main="Steps per 5-minute interval across days")
max(stepsPerInterval)
?subset
maxInterval<-subset(stepsPerInterval,stepsPerInterval=max(stepsPerInterval))
maxInterval<-subset(stepsPerInterval,stepsPerInterval=max(stepsPerInterval))
maxInterval<-subset(stepsPerInterval, stepsPerInterval==max(stepsPerInterval))
maxInterval
print(maxInterval[1])
class(maxInterval)
print(name(maxInterval))
?name
print(names(maxInterval))
?completecases
?completeCases
?complete.cases
nrow(subset(steps, steps$steps==is.na)) #Calculate total number of NAs
class(steps)
nrow(subset(steps, is.na(steps$steps)) #Calculate total number of NAs
nrow(subset(steps, is.na(steps$steps))) #Calculate total number of NAs
nrow(subset(steps, is.na(steps))) #Calculate total number of NAs
subset(steps, is.na(steps)) #Calculate total number of NAs
nrow(subset(steps, is.na(steps))) #Calculate total number of NAs
nrow(steps)
imputedSteps<-apply(steps, function (x) {
if(is.na(steps))
if (x>1 && steps[x-1]!=NA && steps[x+1]!=NA)
steps[x,1]<-(steps[x-1]+steps[x+1])/2
else steps[x,1]<-1
})
imputedSteps<-apply(steps, function(x) {
if(is.na(steps))
if (x>1 && steps[x-1]!=NA && steps[x+1]!=NA)
steps[x,1]<-(steps[x-1]+steps[x+1])/2
else steps[x,1]<-1
})
?apply
?sapply
imputedSteps<-sapply(steps, function(x) {
if(is.na(steps))
if (x>1 && steps[x-1]!=NA && steps[x+1]!=NA)
steps[x,1]<-(steps[x-1]+steps[x+1])/2
else steps[x,1]<-1
})
imputedSteps<-sapply(steps, function(x) {
if(is.na(steps))
if (steps[x+1]!=NA)
steps[x,1]<-[x+1]
else steps[x,1]<-1
})
imputedSteps<-sapply(steps, function(x) {
if(is.na(steps))
if (steps[x+1]!=NA) steps[x,1]<-[x+1]
#else steps[x,1]<-1
})
imputedSteps<-sapply(steps, function(x) {
if(is.na(steps))
if (steps[x+1,1]!=NA) steps[x,1]<-steps[x+1,1]
#else steps[x,1]<-1
})
imputedSteps<-sapply(steps, function(x) {
if(is.na(steps))
if (!is.na(steps[x+1,1]) steps[x,1]<-steps[x+1,1]
#else steps[x,1]<-1
})
impute<-function(x) {
if(is.na(steps))
if (!is.na(steps[x+1,1]) steps[x,1]<-steps[x+1,1]
#else steps[x,1]<-1
}
impute<-function(x) {
if(is.na(steps))
if (!is.na(steps[x+1,1]) steps[x,1]<-steps[x+1,1]
#else steps[x,1]<-1}
impute<-function(x) {
if(is.na(steps))
if (!is.na(steps[x+1,1])) steps[x,1]<-steps[x+1,1]}
#else steps[x,1]<-1}
imputedSteps<-sapply(steps, impute)
impute<-function(x) {
if(is.na(steps[x,1]))
if (!is.na(steps[x+1,1])) steps[x,1]<-steps[x+1,1]}
#else steps[x,1]<-1}
imputedSteps<-sapply(steps, impute)
impute<-function(x) {
if(is.na(steps[x,1]))
if (!is.na(steps[(x+1),1])) steps[x,1]<-steps[(x+1),1]}
imputedSteps<-sapply(steps, impute)
steps[1,1]
head(steps)
steps<-read.csv("activity.csv")             #load the data
head(steps)
class(stepsPerDay)
stepsPerDay
stepsPerDay<-sapply(byInterval, sum, na.rm=TRUE)            #add steps in intervals
stepsPerDay
?is.na
is.na(steps$steps)
?apply
missing<- steps[!complete.cases(steps),] # list rows of data that have missing values
missing
steps<-read.csv("activity.csv")             #load the data
row.names(steps)<-c(1:nrow(steps))
missing<- steps[!complete.cases(steps),] # list rows of data that have missing values
missing
head(missing)
missing<-is.na(steps$steps) #returns true/false vector
head(missing)
stepsPerInterval
impute<- function(x)
{
if(missing[x]) steps[x,1]<-stepsPerInterval[x]
}
sapply(steps, impute)
steps[1,1]
impute<- function(x)
{
if(is.na(steps[x,1])) steps[x,1]<-stepsPerInterval[x]
}
sapply(steps, impute)
sum(is.na(stepsPerInterval))
